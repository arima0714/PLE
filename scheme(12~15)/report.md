# 関数型プログラミング言語 Scheme レポート

##### 氏名：有馬海人
##### 学籍番号：1710021

## 課題1

### 設計上の留意点

ヒントを参考にしつつも、ヒントの項にある「線形リストを対象とする単純なmap」を実際に動かしてみることを筆頭に、まだできていないことを小さく分解して完成に近づけて行くという手法を取ろうと考えたため、急がずに不明点を明らかにしていきつつ、課題を進めていくということに留意した。

### 実行例

課題1-1の入力例は下記である

```
(define TREE00 '(1 2 3 4 5))
"-----課題1-1テスト-----"
(map-tree even? TREE)
;(#f (#t (#f #t)) #t (#f #t #f))
(map-tree (lambda (x) (* x x)) TREE)
;(1 (4 (9 16)) 36 (49 64 81))
(map-tree even? TREE00)
;(#f #t #f #t #f)
(map-tree (lambda (x) (* x x)) TREE00)
;(1 4 9 16 25)
```

課題1-1の実行結果は下記のようになった

```
"-----課題1-1テスト-----"
(#f (#t (#f #t)) #t (#f #t #f))
(1 (4 (9 16)) 36 (49 64 81))
(#f #t #f #t #f)
(1 4 9 16 25)
```

課題1-2の入力例は下記である。

```
"-----課題1-2テスト-----"
(map-tree2 even? TREE)
;(#f (#t (#f #t)) #t (#f #t #f))
(map-tree2 (lambda (x) (* x x)) TREE)
;(1 (4 (9 16)) 36 (49 64 81))
(map-tree2 even? TREE00)
;(#f #t #f #t #f)
(map-tree2 (lambda (x) (* x x)) TREE00)
;(1 4 9 16 25)
```

課題1-2の実行結果は下記のようになった

```
"-----課題1-2テスト-----"
(#f (#t (#f #t)) #t (#f #t #f))
(1 (4 (9 16)) 36 (49 64 81))
(#f #t #f #t #f)
(1 4 9 16 25)
```


### 考察

#### 課題1-1

本課題においてこのプログラムは題意を満たしたプログラムあると考察する。
実行例の上二つは課題のWEBページに記載されていたものであるが、これの実行例は同じWEBページある実行例と同じになったため、リストの中のリストのような複雑な形に対応することができていると考察できる。また、実行例のした二つは、単に数字がリストとして格納されているだけのものとなっており、これの実行結果も手計算したものと同じなので、単純な形にも対応することができたと考察できる。以上より、単純・複雑問わず対応することができているので `map-tree` 関数は題意を満たしたプログラムであると考察する。

#### 課題1-2

このプログラムの作成にあたって、工夫を要した点は無名関数という技術の導入と引数として渡された値の利用である。
また、本課題においてこのプログラムは題意を満たしたプログラムであると考察する。
`map-tree2` 関数内では `cons`, `car`, `cdr` のそれぞれを用いることなく、 `map-tree` と同じ入力例で同じ出力を下からである。

## 課題2

### 設計上の留意点

この課題については、私は今までのプログラミング系課題において仮定の部分を見過ごして不要な記述を大量生産してしまったという経験があるので、提示された仮定を把握して不要な記述を防ぐとともに、仮定を把握した上でのアルゴリズムを構築するよいうことを留意しながらコードの作成を行った。

### 実行例

課題2-1の入力例は下記である。

```
"get-depth 実行結果 begin"
"get-depth kakeizu 1 <- executed"
(get-depth kakeizu 1)
"get-depth kakeizu 2 <- executed"
(get-depth kakeizu 2)
"get-depth kakeizu 3 <- executed"
(get-depth kakeizu 3)
"get-depth kakeizu 4 <- executed"
(get-depth kakeizu 4)
"get-depth kakeizu 6 <- executed"
(get-depth kakeizu 6)
"get-depth kakeizu 11 <- executed"
(get-depth kakeizu 11)
"get-depth 実行結果 end"
```

課題2-1の実行結果は下記のようになった

```
"get-depth 実行結果 begin"
"get-depth kakeizu 1 <- executed"
(義直 秀忠 頼宣 頼房)
"get-depth kakeizu 2 <- executed"
(光友 家光 光貞 頼重 光圀)
"get-depth kakeizu 3 <- executed"
(綱誠 綱吉 綱重 家綱 綱教 頼職 吉宗 綱条 頼候)
"get-depth kakeizu 4 <- executed"
(家宣 宗尹 家重 宗武)
"get-depth kakeizu 6 <- executed"
(家斎 斎敦 斎匡)
"get-depth kakeizu 11 <- executed"
()
"get-depth 実行結果 end"
```

課題2-2の入力例は下記である。

```
"get-cousin 実行結果 begin"
"(get-cousin kakeizu '秀忠 <- executed"
(get-cousin kakeizu '秀忠)
"(get-cousin kakeizu '吉宗 <- executed"
(get-cousin kakeizu '吉宗)
"(get-cousin kakeizu '家継 <- executed"
(get-cousin kakeizu '家継)
"(get-cousin kakeizu '家達 <- executed"
(get-cousin kakeizu '家達)
"(get-cousin kakeizu '家 <- executed"
(get-cousin kakeizu '家)
"get-cousin 実行結果 end"
```

課題2-2の実行結果は下記のようになった

```
"get-cousin 実行結果 begin"
"(get-cousin kakeizu '秀忠 <- executed"
(義直 秀忠 頼宣 頼房)
"(get-cousin kakeizu '吉宗 <- executed"
(綱誠 綱吉 綱重 家綱 綱教 頼職 吉宗 綱条 頼候)
"(get-cousin kakeizu '家継 <- executed"
(家継 治済 家治 重好 治察 定国 定信)
"(get-cousin kakeizu '家達 <- executed"
(家定 慶昌 家茂 昌丸 家達)
"(get-cousin kakeizu '家 <- executed"
()
"get-cousin 実行結果 end"
```

### 考察

#### 課題2-1

このプログラムを作成するにあたって工夫した点は下記の通りである。
1. 括弧の関係をわかりやすくするために改行・インデントを多用することでプログラムの可読性をあげた
2. 再帰の基本である、ベースケースとそれ以外の場合の処理を事前にコメントという形で先に記述することで、自分の中での混乱を減らしたこと
また、このプログラムは題意を満たしたプログラムであると考える。
その理由は入力された第二引数が1~6のように何らかの値が返り値として出力されるものに関しては「徳川家家系図(抜粋)」と照らし合わせた結果、問題ないものであった。また、入力された第二引数が11というように返り値が空のリストであるものに関しても、空のリストを返すということができたからである。

#### 課題2-2

このプログラムは題意を満たしたプログラムであると考える。
理由は課題のWEBページに記載されていた入力例に対する出力はこのプログラムでも同じものを出力することができた。また、この家系図の入力でもっとも家康から離れている「家達」に関しても出力は想定していたものと同じものが出てきたということと、家系図に存在しない「家」を第二引数とした場合も想定していた空のリストを出力したからである。
このプログラムの課題点は、検索をするにあたって `get-depth` を複数回実行しているということである。深さを数字で得るためと最終的な出力のためにそれぞれ `get-depth` を使用しているからである。これをまとめることができるとよりようコードになると考察する。

## 課題3

### 設計上の留意点

#### 課題3-1について

この課題については課題1-1と同様になってしまうが、一気に実装するのではなく、
1. 入力が1ならば0が出力されるプログラム
2. 入力がxならば1が出力されるプログラム
3. 入力が1+xならば0+1が出力されるプログラム
4. ... 
のような順に万能なプログラムを最初から作るのではなく徐々に機能を充実化させていくというような方針で作成していった。

#### 課題3-2について

この課題については、自分は今までは数式を扱うようなプログラミング課題にて手計算を行わずにアルゴリズムを脳内で考えて実装して、小さなミスにも気づかず長時間を消費してしまったという経験から、最初は手計算をすることによって目標とする数式を導出した上で実際にコードに実装するという手順をとるということに留意しつつ作成しようとした。

### 実行例

#### 課題3-1実行例

実行時の入力例は下記である。

```
#(diff 5)
(diff 5)
#(diff 'x)
(diff 'x)
#(diff '(+ x 5))
(diff '(+ x 5))
#(diff '(- x 5))
(diff '(- x 5))
#(diff '(* 5 x))
(diff '(* 5 x))
#(diff '(** x 2))
(diff '(** x 2))
#(diff '(+ (** x 3) (* 2 x) 4))
(diff '(+ (** x 3) (* 2 x) 4))
#(diff '(** (* x 3) 2))
(diff '(** (* x 3) 2))
#(diff '(* (+ x 2) (- (** x 2) x)))
(diff '(* (+ x 2) (- (** x 2) x)))
```

実行結果は下記のようになった


```
#(diff 5)
0
#(diff 'x)
1
#(diff '(+ x 5))
(+ 1 0)
#(diff '(- x 5))
(- 1 0)
#(diff '(* 5 x))
(+ (* 5 1) (* 0 x))
#(diff '(** x 2))
(* 2 (* 1 (** x 1)))
#(diff '(+ (** x 3) (* 2 x) 4))
(+ (* 3 (* 1 (** x 2))) (+ (* 2 1) (* 0 x)) 0)
#(diff '(** (* x 3) 2))
(* 2 (* (+ (* x 0) (* 1 3)) (** (* x 3) 1)))
#(diff '(* (+ x 2) (- (** x 2) x)))
(+ (* (+ x 2) (- (* 2 (* 1 (** x 1))) 1)) (* (+ 1 0) (- (** x 2) x)))
```

#### 課題3-2実行例

実行時の入力例は下記である。

```
#(tangent '(+ (** x 3) (* -2 (** x 2)) 9) 2)
(diff '(+ (** x 3) (* -2 (** x 2)) 9))
#(tangent '(+ (** x 3) (* -2 (** x 2)) 9) 2)
(tangent '(+ (** x 3) (* -2 (** x 2)) 9) 2)
```

実行結果は下記のようになった


```
#(tangent '(+ (** x 3) (* -2 (** x 2)) 9) 2)
(+ (* 3 (* 1 (** x 2))) (+ (* -2 (* 2 (* 1 (** x 1)))) (* 0 (** x 2))) 0)
#(tangent '(+ (** x 3) (* -2 (** x 2)) 9) 2)
(+ (* 4 x) 1)
```


### 考察
